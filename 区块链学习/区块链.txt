# 以太坊简介

## 区块链（公链）发展简史

比特币（1.0）—> 以太坊（2.0）—>？（3.0）

比特币知识简单的记账

以太坊是智能合约



比特币：点对点的电子现金系统

以太坊：智能合约和去中心化应用平台

智能合约：一个自动化程序



## 以太坊特点

开源的、全球分布的计算基础设施

执行称为智能合约的程序

使用区块链来同步和存储系统状态以及为以太币的加密货币，计量和约束执行资源成本

本质是一个基于交易的状态机

（跟踪所有状态）

以太坊平台使开发人员能够构建具有内置经济功能的强大去中心化应用程序DApp，在持续自我正常运行的同时，它还减少或消除了审查，第三方界面和交易对手风险

以太坊是图灵完备的，理论上可以运行“无限循环”的程序

## 以太坊的组成部分

- P2P网络

- TCP端口30303

- 交易

  交易是网络消息，其中包括发送者、接受者、值、数据的有效载荷

- 以太网虚拟机EVM

  执行字节码的基于堆栈的虚拟机

- 数据库

- 客户端

- 账户

  包含地址，余额和随机数，已经可选的存储和代码的对象

  普通账户EOA：存储和代码为空

  合约账户Contract：包含存储和代码

- 地址

  代表一个EOA或合约，可以在区块链上接收或发送交易

- 交易

  可以发送以太币和信息

  向合约发送的交易可以调用合约代码，并以信息数据为函数参数

  向空用户发送信息，可以自动生成以信息为代码块的合约账户

- gas

  以太网执行智能合约需要的虚拟燃料

## 以太坊的货币

以太坊的货币单位称为以太（ether、ETH）



挖矿产出—>这样一套基于POW的奖励机制称为以太网的“幽灵协议”

- 区块奖励

- 叔块（同时挖出来但是被挖得稍晚）奖励

- 叔块引用奖励



以太坊出块机制从工作量证明PoW转换为股权证明PoS

## 以太坊区块收入

- 普通区块收入

- 叔块收入

## 区块链浏览器

etherscan.io

## 去中心化应用

基于以太坊可以创建智能合约来构建去中心化应用DApp

以太坊的构想是成为DApps编程开发的平台

DApp至少由以下组成：

- 区块链上的智能合约

- Web前端用户界面

## 以太坊应用

- 加密货币

- 创建域名注册系统、博彩系统

- 开发去中心化游戏

  以太猫

## 代币

也称通证token，代表有所有权的资产、货币、权限等在区块链上的抽象

- 可替代性通证：指的是基于区块链技术发行的，相互可以代替的，可以接近无限拆分的token

- 非同质通证：指的是基于区块链技术发行的，唯一的，不可代替的，大多数情况下不可拆分的token

## 名次解释

EIP 

ERC

EOA：由以太坊网络的人类用户创建的账户

Ethash

HD钱包：使用分层确定性密钥创建和转账协议的钱包

Keccak256：以太坊中使用的密码哈希函数

Nonce：代指只能使用一次的值，以太坊使用两种类型的随机数，账户随机数和POW随机数

# 初识以太坊

##  钱包、测试网络和简单交易

### 以太坊钱包

以太坊钱包是我们进入以太坊系统的门户，包含了私钥，可以代表我们创建和广播交易。

MetaMask：一个浏览器扩展钱包，可在浏览器中运行

Jaxx：一款多平台、多币种的钱包，可在各种操作系统上运行，包括Android，iOS，Windows，Mac，Linus

MyEtherWallet(MEW)：一个基于web的钱包，可以在任何浏览器中运行

Emerald Wallet：旨在与ETC配合使用，但与其他以太坊的区块链兼容

### 私钥、公钥和地址

私钥：256位随机数，用于发送以太的交易中创建签名来证明自己对资金的所有权

​	助记词是明文私钥的另一种表现形式

公钥：由私钥通过椭圆曲线加密secp256k1算法单向生成的512位（64字节）数

地址：公钥的Keccak-256单项哈希，取最后20字节派生出来的标识符

## 主网络和测试网络

![alt](\1.png)

可以用Rinkeby

## 发送交易

## 初识以太坊合约

查询当前以太坊区块gas的状态ethgassstation.info

在线的Solidity编辑器remix.ethereum.org

把以太坊当后端用方式：写合约部署到以太坊上

# 智能合约入门

```solidity
pragma solidity ^0.4.19;

contract xlyFaucet{
    //  提取
    function withdraw(uint withdraw_amount) public {
        // 必须满足的条件 
        require(withdraw_amount<=1000000000000000000);
        //  给 sender转币,调用地址
        msg.sender.transfer(withdraw_amount);
    }
    
    //发出的消息没有调用合约的函数个，就调用这个    
    function() public payable{}
}
```

# 以太坊客户端

## 什么是以太坊客户端

• 以太坊客户端是一个软件应用程序，它实现以太坊规范并通过p2p
网络与其他以太坊客户端进行通信。如果不同的以太坊客户端符合
参考规范和标准化通信协议，则可以进行相互操作。
• 以太坊是一个开源项目，由“黄皮书”正式规范定义。除了各种以
太坊改进提案之外，此正式规范还定义了以太坊客户端的标准行为。
• 因为以太坊有明确的正式规范，以太网客户端有了许多独立开发的
软件实现，它们之间又可以彼此交互。

## 以太坊全节点

• 全节点是整个主链的一个副本，存储并维护链上的所有数据，并随
时验证新区块的合法性。
• 区块链的健康和扩展弹性，取决于具有许多独立操作和地理上分散
的全节点。每个全节点都可以帮助其他新节点获取区块数据，并提
供所有交易和合约的独立验证。
• 运行全节点将耗费巨大的成本，包括硬件资源和带宽。
• 以太坊开发不需要在实时网络（主网）上运行的全节点。我们可以
使用测试网络的节点来代替，也可以用本地私链，或者使用服务商
提供的基于云的以太坊客户端；这些几乎都可以执行所有操作。

优点
• 为以太坊网络的灵活性和抗审查性提供有力支持。
• 权威地验证所有交易。
• 可以直接与公共区块链上的任何合约交互。
• 可以离线查询区块链状态（帐户，合约等）。
• 可以直接把自己的合约部署到公共区块链中。
缺点
• 需要巨大的硬件和带宽资源，而且会不断增长。
• 第一次下载往往需要几天才能完全同步。
• 必须及时维护、升级并保持在线状态以同步区块。

## 远程客户端和轻节点

• 远程客户端
不存储区块链的本地副本或验证块和交易。这些客户端一般只提供钱包的功能，可以创建和广播交易。远程客户端可用于连接到现有网络，MetaMask 就是一个这样的客户端。
• 轻节点
不保存链上的区块历史数据，只保存区块链当前的状态。轻节点可以对块和交易进行验证。

## 公共测试网络节点的优缺点

优点
• 一个 testnet 节点需要同步和存储更少的数据，大约10GB，具体取决于不同的网络。
• 一个 testnet 节点一般可以在几个小时内完全同步。
• 部署合约或进行交易只需要发送测试以太，可以从“水龙头”免费获得。
• 测试网络是公共区块链，有许多其他用户和合约运行（区别于私链）。
缺点
• 测试网络上使用测试以太，它没有价值。因此，无法测试交易对手的安全性，因为没有任何利害关系。
• 测试网络上的测试无法涵盖所有的真实主网特性。例如，交易费用虽然是发送交易所必需的，但由于gas免费，因此 testnet 上往往不会考虑。而且一般来说，测试网络不会像主网那样经常拥堵。

##　本地私链的优缺点

优点
• 磁盘上几乎没有数据，也不同步别的数据，是一个完全“干净”的环境。
• 无需获取测试以太，你可以任意分配以太，也可以随时自己挖矿获得。
• 没有其他用户，也没有其他合约，没有任何外部干扰。
缺点
• 没有其他用户意味与公链的行为不同。发送的交易并不存在空间或交易顺序的竞争。
• 除自己之外没有矿工意味着挖矿更容易预测，因此无法测试公链上发生的某些情况。
• 没有其他合约，意味着你必须部署要测试的所有内容，包括所有的依赖项和合约库。

## geth（Go-Ethereum）

• Geth是由以太坊基金会积极开发的 Go 语言实现，因此被认为是以太坊客户端的“官方”实现。
• 通常，每个基于以太坊的区块链都有自己的Geth实现。

## JSON-RPC

• 以太坊客户端提供了API 和一组远程调用（RPC）命令，这些命令被编码为 JSON。这被称为 JSON-RPC API。本质上，JSON-RPC API 就是一个接口，允许我们编写的程序使用以太坊客户端作为网关，访问以太坊网络和链上数据。
• 通常，RPC 接口作为一个 HTTP 服务，端口设定为 8545。出于安全原因，默认情况下，它仅限于接受来自localhost 的连接。
• 要访问JSON-RPC API，我们可以使用编程语言编写的专用库，例如JavaScript的 web3.js。
• 或者也可以手动构建HTTP请求并发送/接收JSON编码的请求，如

```
$ curl -X POST -H "Content-Type: application/json" --data \
'{"jsonrpc":"2.0","method":"web3_clientVersion","params":[],"id":1
}' \ http://localhost:8545
```



# 用geth搭建以太坊私链

![alt](\2.png)

alloc给创世节点分配以太 单位是wei

# 以太坊账户与合约

## EOA外部账户（用户账户/普通账户）

• 有对应的以太币余额
• 可发送交易（转币或触发合约代码）
• 由用户私钥控制
• 没有关联代码

##　合约账户（内部账户）

• 有对应的以太币余额
• 有关联代码
• 由代码控制
• 可通过交易或来自其它合约的调用消息来触发代
码执行
• 执行代码时可以操作自己的存储空间，也可以调
用其它合约

## 消息（Message）

-- 合约可以向其它合约发送“消息”
-- 消息是不会被序列化的虚拟对象，只存在于以太坊执行环境
（EVM）中
-- 可以看作函数调用
• 消息发送方
• 消息接收方
• 金额（VALUE）
• 数据（DATA，可选）
• START GAS

## 合约（Contract）

• 可以读/写自己的内部存储（32字节key-value的
数据库）
• 可向其他合约发送消息，依次触发执行
• 一旦合约运行结束，并且由它发送的消息触发的所有子执行（sub-execution）结束，EVM就会中止运行，直到下次交易被唤醒

## 合约应用

• 维护一个数据存储（账本），存放对其他合约或外部世界有用的内容
• 最典型的例子是模拟货币的合约（代币）

• 通过合约实现一种具有更复杂的访问策略的普通账户（EOA），这被称为“转发合同”：只有在满足某些条件时才会将传入的消息重新发送到某个所需的目的地址；例如，一个人可以拥有一份转发合约，该合约会等待直到给定三个私钥中的两个确认之后，再重新发送特定消息
• 钱包合约是这类应用中很好的例子

• 管理多个用户之间的持续合同或关系
• 这方面的例子包括金融合同，以及某些特定的托管合同或某种保险

# 交易详解

## 交易的本质

• 交易是由外部拥有的账户发起的签名消息，由以太坊网络传输，并被序列化后记录在以太坊区块链上。
• 交易是唯一可以触发状态更改或导致合约在EVM中执行的事物。
• 以太坊是一个全局单例状态机，交易是唯一可以改变其状态的东西。
• 合约不是自己运行的，以太坊也不会“在后台”运行。以太坊上的一切变化都始于交易。

## 交易数据结构

交易是包含以下数据的序列化二进制消息：
• nonce：由发起人EOA发出的序列号，用于防止交易消息重播。
• gas price：交易发起人愿意支付的gas单价（wei）。
• start gas：交易发起人愿意支付的最大gas量。
• to：目的以太坊地址。
• value：要发送到目的地的以太数量。
• data：可变长度二进制数据负载（payload）。
• v,r,s：发起人EOA的ECDSA签名的三个组成部分。
• 交易消息的结构使用递归长度前缀（RLP）编码方案进行序列化，该方案专为在以太坊中准确和字节完美的数据序列化而创建。

## 交易中的nonce

• 黄皮书定义： 一个标量值，等于从这个地址发送的交易数，或者对于关联code的帐户来说，是这个帐户创建合约的数量。
• nonce不会明确存储为区块链中帐户状态的一部分。相反，它是通过计算发送地址的已确认交易的数量来动态计算的。
• nonce值还用于防止错误计算账户余额。nonce强制来自任何地址的交易按顺序处理，没有间隔，无论节点接收它们的顺序如何。
• 使用nonce确保所有节点计算相同的余额和正确的序列交易，等同于用于防止比特币“双重支付”（“重放攻击”）的机制。但是，由于以太坊跟踪账户余额并且不单独跟踪 UTXO ，因此只有在错误地计算账户余额时才会发生“双重支付”。nonce机制可以防止这种情况发生。

## 并发和nonce

• 以太坊是一个允许操作（节点，客户端，DApps）并发的系统，但强制执行单例状态。例如，出块的时候只有一个系统状态。
• 假如我们有多个独立的钱包应用或客户端，比如 MetaMask和 Geth，它们可以使用相同的地址生成交易。如果我们希望它们都够同时发送交易，该怎么设置交易的nonce呢？
• 用一台服务器为各个应用分配nonce，先来先服务——可能出现单点故障，并且失败的交易会将后续交易阻塞。
• 生成交易后不分配nonce，也不签名，而是把它放入一个队列等待。另起一个节点跟踪nonce并签名交易。同样会有单点故障的可能，而且跟踪nonce和签名的节点是无法实现真正并发的。

## 交易中的gas

• 当由于交易或消息触发 EVM 运行时，每个指令都会在网络的每个节点上执行。这具有成本：对于每个执行的操作，都存在固定的成本，我们把这个成本用一定量的 gas 表示。
• gas 是交易发起人需要为 EVM 上的每项操作支付的成本名称。发起交易时，我们需要从执行代码的矿工那里用以太币购买 gas 。
• gas 与消耗的系统资源对应，这是具有自然成本的。因此在设计上 gas 和ether 有意地解耦，消耗的 gas 数量代表了对资源的占用，而对应的交易费用则还跟 gas 对以太的单价有关。这两者是由自由市场调节的：gas 的价格实际上是由矿工决定的，他们可以拒绝处理 gas 价格低于最低限额的交易。

## 交易的接收者（to）

• 交易接收者在to字段中指定，是一个20字节的以太坊地址。地址可以是EOA或合约地址。
• 以太坊没有进一步的验证，任何20字节的值都被认为是有效的。如果20字节值对应于没有相应私钥的地址，或不存在的合约，则该交易仍然有效。以太坊无法知道地址是否是从公钥正确派生的。
• 如果将交易发送到无效地址，将销毁发送的以太，使其永远无法访问。
• 验证接收人地址是否有效的工作，应该在用户界面一层完成。

##　交易的 value 和 data

• 交易的主要“有效负载”包含在两个字段中：value 和 data。交易可以同时有 value 和 data，仅有 value，仅有 data，或者既没有 value也没有 data。所有四种组合都有效。
• 仅有 value 的交易就是一笔以太的付款
• 仅有 data 的交易一般是合约调用
• 进行合约调用的同时，我们除了传输 data， 还可以发送以太，从而交易中同时包含 data 和 value
• 没有 value 也没有 data 的交易，只是在浪费 gas，但它是有效的

##　向 EOA 或合约传递 data
• 当交易包含数据有效负载时，它很可能是发送到合约地址的，但它同样可以发送给 EOA
• 如果发送 data 给 EOA，数据负载（data payload） 的解释取决于钱包
• 如果发送数据负载给合约地址，EVM 会解释为函数调用，从 payload 里解码出函数名称和参数，调用该函数并传入参数
• 发送给合约的数据有效负载是32字节的十六进制序列化编码：
——函数选择器：函数原型的 Keccak256 哈希的前4个字节。这允许EVM 明确地识别将要调用的函数。
——函数参数：根据 EVM 定义的各种基本类型的规则进行编码。

## 特殊交易：创建（部署）合约

• 有一中特殊的交易，具有数据负载且没有 value，那就是一个创建新合约的交易。
• 合约创建交易被发送到特殊目的地地址，即零地址0x0。该地址既不代表 EOA 也不代表合约。它永远不会花费以太或发起交易，它仅用作目的地，具有特殊含义“创建合约”。
• 虽然零地址仅用于合同注册，但它有时会收到来自各种地址的付款。这种情况要么是偶然误操作，导致失去以太；要么是故意销毁以太。
• 合约注册交易不应包含以太值，只包含合约的已编译字节码的数据有效负载。此交易的唯一效果是注册合约。

# 以太坊虚拟机（EVM）

## EVM是什么

• 以太坊虚拟机 EVM 是智能合约的运行环境
• 作为区块验证协议的一部分，参与网络的每个节点都会运行EVM。他们会检查正在验证的块中列出的交易，并运行由EVM中的交易触发的代码
• EVM不仅是沙盒封装的，而且是完全隔离的，也就是说在EVM 中运行的代码是无法访问网络、文件系统和其他进程的，甚至智能合约之间的访问也是受限的
• 合约以字节码的格式（EVM bytecode）存在于区块链上
• 合约通常以高级语言（solidity）编写，通过EVM编译器编译为字节码，最终通过客户端上载部署到区块链网络中

## EVM和账户
• 以太坊中有两类账户： 外部账户 和 合约账户，它们共用EVM中同一个地址空间
• 无论帐户是否存储代码，这两类账户对 EVM 来说处理方式是完全一样的
• 每个账户在EVM中都有一个键值对形式的持久化存储。其中 key 和 value 的长度都是256位，称之为 存储空间（storage）

## EVM和交易
• 交易可以看作是从一个帐户发送到另一个帐户的消息，它可以包含二进制数据（payload）和以太币
• 如果目标账户含有代码，此代码会在EVM中执行，并以payload 作为入参，这就是合约的调用
• 如果目标账户是零账户（账户地址为 0 )，此交易就将创建一个 新合约 ，这个用来创建合约的交易的 payload 会被转换为 EVM 字节码并执行，执行的输出作为合约代码永久存储

## EVM和gas
• 合约被交易触发调用时，指令会在全网的每个节点上执行：这需要消耗算力成本；每一个指令的执行都有特定的消耗，gas 就用来量化表示这个成本消耗
• 一经创建，每笔交易都按照一定数量的 gas 预付一笔费用，的是限制执行交易所需要的工作量和为交易支付手续费
• EVM 执行交易时，gas 将按特定规则逐渐耗尽
• gas price 是交易发送者设置的一个值，作为发送者预付手续费的单价。如果交易执行后还有剩余，gas 会原路返还
• 无论执行到什么位置，一旦 gas 被耗尽（比如降为负值），将会触发一个 out-of-gas 异常。当前调用帧（call frame）所做的所有状态修改都将被回滚

## EVM数据存储

Storage
• 每个账户都有一块**持久化**的存储空间，称为 storage，这是一个将256位字映射到256位字的key-value 存储区，可以理解为合约的数据库
• 永久储存在区块链中，由于会永久保存合约状态变量，所以读写的 gas 开销也最大

Memory（内存）
• 每一次消息调用，合约会**临时**获取一块干净的内存空间
• 生命周期仅为整个方法执行期间，函数调用后回收，因为仅保存临时变量，故读写 gas 开销较
小
Stack（栈）
• EVM 不是基于寄存器的，而是**基于栈**的，因此所有的计算都在一个被称为栈（stack）的区域
执行
• 存放部分局部值类型变量，几乎免费使用的内存，但有数量限制

## EVM指令集

• 所有的指令都是针对"256位的字（word）"这个基本的数据类型来进行操作
• 具备常用的算术、位、逻辑和比较操作，也可以做到有条件和无条件跳转
• 合约可以访问当前区块的相关属性，比如它的块高度和时间戳

## 消息调用（ Message Calls ）

• 合约可以通过消息调用的方式来调用其它合约或者发送以太币到非合约账户
• 合约可以决定在其内部的消息调用中，对于剩余的 gas ，应发送和保留多少
• 如果在内部消息调用时发生了 out-of-gas 异常（或其他任何异常），这将由一个被压入栈顶的错误值所指明；此时只有与该内部消息调用一起发送的 gas 会被消耗掉

## 委托调用（Delegatecall）

• 一种特殊类型的消息调用
• 目标地址的代码将在发起调用的**合约的上下文中执行**，并且 msg.sender 和 msg.value 不变
• 可以由此实现“库”（library）：可复用的代码库可以放在一个合约的存储上，通过委托调用引入相应代码

## 合约的创建和自毁

• 通过一个特殊的消息调用 create calls，合约可以创建其他合约（不是简单的调用零地址）
• 合约代码从区块链上移除的唯一方式是合约在合约地址上的执行自毁操作 selfdestruct ；合约账户上剩余的以太币会发送给指定的目标，然后其存储和代码从状态中被移除

# Solidity 简介

## Solidity是什么

• Solidity 是一门面向合约的、为实现智能合约而创建的高级编程语言。这门语言受到了 C++，Python 和 Javascript 语言的影响，设计的目的是能在以太坊虚拟机（EVM）上运行。
• Solidity 是静态类型语言，支持继承、库和复杂的用户定义类型等特性。
• 内含的类型除了常见编程语言中的标准类型，还包括 address等以太坊独有的类型，Solidity 源码文件通常以 .sol 作为扩展名
• 目前尝试 Solidity 编程的最好的方式是使用 Remix。Remix是一个基于 Web 浏览器的 IDE，它可以让你编写 Solidity 智能合约，然后部署并运行该智能合约。

## Solidity语言特性

Solidity的语法接近于JavaScript，是一种面向对象的语言。但作为一种真正意义上运行在网络上的去中心合约，它又有很多的不同：
• 以太坊底层基于帐户，而不是 UTXO，所以增加了一个特殊的address 的数据类型用于**定位用户和合约账户**。
• 语言内嵌框架支持支付。提供了 payable 等关键字，可以在语言层面直接支持支付。
• 使用区块链进行数据存储。数据的每一个状态都可以永久存储，所以在使用时需要确定变量使用内存，还是区块链存储。
• 运行环境是在去中心化的网络上，所以需要强调合约或函数执行的调用的方式。
• 不同的异常机制。一旦出现异常，所有的执行都将会被回撤，这主要是为了保证合约执行的原子性，以避免中间状态出现的数据不一致。

## Solidity源码和智能合约

• Solidity 源代码要成为可以运行在以太坊上的智能合约需要经历如下的步骤：
1. 用 Solidity 编写的智能合约源代码需要先使用编译器编译为字节码（Bytecode），编译过程中会同时产生智能合约的二进制接口规范（Application Binary Interface，简称为ABI）；
2. 通过交易（Transaction）的方式将字节码部署到以太坊网络，每次成功部署都会产生一个新的智能合约账户；
3. 使用 Javascript 编写的 DApp 通常通过 web3.js + ABI去调用智能合约中的函数来实现数据的读取和修改。

## Solidity编译器
Remix
• Remix 是一个基于 Web 浏览器的 Solidity IDE；可在线使用而无需安装任何东西
• http://remix.ethereum.org
solcjs
• solc 是 Solidity 源码库的构建目标之一，它是 Solidity 的命令行编译器
• 使用 npm 可以便捷地安装 Solidity 编译器 solcjs
• npm install -g solc

## 智能合约概述

Solidity中合约
• 一组代码（合约的 函数 )和数据（合约的 状态 ），它们位于以太坊区块链的一个特定地址上
• 代码行 uint storedData; 声明一个类型为 uint (256位无符号整数）的状态变量，叫做 storedData
• 函数 set 和 get 可以用来变更或取出变量的值

## 合约结构

• 状态变量（State Variables）
	作为合约状态的一部分，值会永久保存在存储空间内。
• 函数（Functions）
	合约中可执行的代码块。
• 函数修饰器（Function Modifiers）
	用在函数声明中，用来补充修饰函数的语义。
• 事件（Events）
	非常方便的 EVM 日志工具接口。

##　例子

```solidity
pragma solidity >0.4.22;
//^表示不大于0.5

//定义自己的存储空间

contract SimpleStorage{
    uint myData;
    function setData(uint newData) public{
        myData = newData;
    }
    
    //view 表示只读不写
    function getData() public view returns(uint){
        return myData;
    }
    
    //  多个返回值
    // puru 表示不读也不写
    function pureAdd(uint a,uint b) public pure returns(uint sum,uint origin_a,uint origin_b){
        return (a+b,a,b);
    }
}
```

```solidity
pragma solidity >0.4.22;

contract Car{
    string brand;
    // 固定长度 
    bytes32 brand1;
    // 相当于多了一个get方法
    uint public price;
    
    // 初始化,合约创建的时候自动调用,function Car被废用
    constructor(string initBrand,uint initPrice) public{
        brand=initBrand;
        price=initPrice;
    }

    function setBrand(string newBrand) public {
        brand = newBrand;
    }
    function getBrand() public view returns(string){
        return brand;
    }
    
    function setBrand1(bytes32 newBrand1) public {
        brand1 = newBrand1;
    }
    function getBrand1() public view returns(bytes32){
        return brand1;
    }
    
    
    function setPrice(uint newPrice) public{
        price = newPrice;
    }
}
```

初始值在deploy的时候给出：

![alt](\4.png)

```solidity
pragma solidity >0.4.22;

contract Coin{
    address public minter;
    mapping(address=>uint) public balances;
    constructor() public{
        //合约的发送者为注币者
        minter = msg.sender;
    }
    
    //发布这样一个事件
    event Sent(address from,address to,uint amount);
    
    function mint(address receiver,uint amount)public{
        require(msg.sender == minter);
        balances[receiver] += amount;
    }
    function send(address receiver,uint amount)public{
        require(balances[msg.sender]>=amount);
        balances[msg.sender] -= amount;
        balances[receiver] += amount;
        
        emit Sent(msg.sender,receiver,amount);
    }
}
```

address **public** minter;
• 这一行声明了一个可以被公开访问的 address 类型的状态变量。
• 关键字 public 自动生成一个函数，允许你在这个合约之外访问这个状态变量的当前值。

**mapping(address => uint)** public balances;
• 也创建一个公共状态变量，但它是一个更复杂的数据类型，该类型将 address 映射为无符号整数。
• mappings 可以看作是一个哈希表，它会执行虚拟初始化，把所有可能存在的键都映射到一个字节表示为全零的值。

**event** Sent(address from, address to, uint amount);
• 声明了一个“事件”（event），它会在 send 函数的最后一行触发
• 用户可以监听区块链上正在发送的事件，而不会花费太多成本。一旦它被发出，监听该事件的listener都将收到通知
• 所有的事件都包含了 from ， to 和 amount 三个参数，可方便追踪事务
**emit** Sent(msg.sender, receiver, amount);
• 触发Sent事件，并将参数传入



改进上一个：

```
pragma solidity >0.4.22;

contract Coin{
    mapping(address=>uint) public balances;
    
    //总量恒定 
    constructor(uint initalSupply) public{
        balances[msg.sender] = initalSupply;
    }
    
    //发布这样一个事件
    event Sent(address from,address to,uint amount);
    
    function send(address receiver,uint amount)public returns(bool success){
        require(balances[msg.sender]>=amount);
        
        //防止溢出 
        require(balances[receiver]+amount > balances[receiver]);
        
        balances[msg.sender] -= amount;
        balances[receiver] += amount;
        
        return true;
        
        emit Sent(msg.sender,receiver,amount);
    }
}
```

## 事件的监听

```web3.js
Coin.Sent().watch({}, '', function(error, result) {
if (!error) {
	console.log("Coin transfer: " + result.args.amount +
		"coins were sent from " + result.args.from +
		" to " + result.args.to + ".");
	console.log("Balances now:\n" +
		"Sender: " +
		Coin.balances.call(result.args.from) +
		"Receiver: " +
		Coin.balances.call(result.args.to));
	}
});
```

就是记录一个log

## 实际实现中(BNB为例)

保证安全的运算:

```
contract SafeMath {
  function safeMul(uint256 a, uint256 b) internal returns (uint256) {
    uint256 c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }

  function safeDiv(uint256 a, uint256 b) internal returns (uint256) {
    assert(b > 0);
    uint256 c = a / b;
    assert(a == b * c + a % b);
    return c;
  }

  function safeSub(uint256 a, uint256 b) internal returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  function safeAdd(uint256 a, uint256 b) internal returns (uint256) {
    uint256 c = a + b;
    assert(c>=a && c>=b);
    return c;
  }

  function assert(bool assertion) internal {
    if (!assertion) {
      throw;
    }
  }
}
```

继承:

```
contract BNB is SafeMath{}
```

冻结和解冻:

```
mapping (address => uint256) public freezeOf;
```

初始总量的拥有者:

```
address public owner;
```

## Ballot一个简单的投票合约（票相当于币）

• 电子投票的主要问题是如何将投票权分配给正确的人员以及如何防止被操纵。 这个合约展示了如何进行委托投票，同时，计票又是自动和完全透明的
• 为每个（投票）表决创建一份合约，然后作为合约的创造者——即主席，将给予每个独立的地址以投票权
• 地址后面的人可以选择自己投票，或者委托给他们信任的人来投票
• 在投票时间结束时，winningProposal() 将返回获得最多投票的提案

# ubuntu指令

git tag 查看所有版本

git checkout v1.8.17 切换版本

geth version 查看当前版本

启动节点同步：

- ​	geth --datadir ./data（/data表示指定目录）

- ​	geth --datadir .（表示当前目录）

- ​	geth –datadir . --syncmode fast（只下载每个区块的内容，但是不验证每一笔交易）full（全部，验证每一步交易）light（区块都不下载，只获得最后的状态）

- geth --testnet --datadir . --syncmode fast（同步测试网络，Ropsten，）
- geth --rinkeby --datadir . --syncmode fast（同步测试网络，rinkeby，）

## 搭建私有链

### 初始化文件genesis.json

```json
{
"config": {
"chainId": 15
},
"difficulty": "2000",
"gasLimit": "2100000",
"alloc": {
"0x717B24495437b9DEE698F14C643e318EA8d7Bd33": { "balance": "300000" }
}
}
```

#### 好用!

```json
{
	"config": {
		"chainId": 123,
		"homesteadBlock": 0,
		"eip150Block": 0,
		"eip155Block": 0,
		"eip158Block": 0,
		"byzantiumBlock": 0,
		"constantinopleBlock": 0,
		"petersburgBlock": 0,
		"istanbulBlock": 0
	},
	"alloc": {
		"0x717B24495437b9DEE698F14C643e318EA8d7Bd33": { "balance": "300000000000000000000000" }
	},
	"coinbase": "0x0000000000000000000000000000000000000000",
	"difficulty": "0x2000",
	"extraData": "",
	"gasLimit": "0x2fefd8",
	"nonce": "0x0000000000000042",
	"mixhash": "0x0000000000000000000000000000000000000000000000000000000000000000",
	"parentHash": "0x0000000000000000000000000000000000000000000000000000000000000000",
	"timestamp": "0x00"
}
```

```json
{
  "config": {
    "chainId": 123,
    "homesteadBlock": 0,
    "eip150Block": 0,
    "eip150Hash": "0x0000000000000000000000000000000000000000000000000000000000000000",
    "eip155Block": 0,
    "eip158Block": 0,
    "byzantiumBlock": 0,
    "constantinopleBlock": 0,
    "petersburgBlock": 0,
    "istanbulBlock": 0,
    "ethash": {}
  },
  "nonce": "0x0",
  "timestamp": "0x5ddf8f3e",
  "extraData": "0x0000000000000000000000000000000000000000000000000000000000000000",
  "gasLimit": "0x47b760",
  "difficulty": "0x00002",
  "mixHash": "0x0000000000000000000000000000000000000000000000000000000000000000",
  "coinbase": "0x0000000000000000000000000000000000000000",
  "alloc": {
    "0x1e82968C4624880FD1E8e818421841E6DB8D1Fa4" : {"balance" : "30000000000000000000"}
  },
  "number": "0x0",
  "gasUsed": "0x0",
  "parentHash": "0x0000000000000000000000000000000000000000000000000000000000000000"
}
```

```js
{
  "config": {
    "chainId": 123,
    "homesteadBlock": 0,
    "eip150Block": 0,
    "eip150Hash": "0x0000000000000000000000000000000000000000000000000000000000000000",
    "eip155Block": 0,
    "eip158Block": 0,
    "byzantiumBlock": 0,
    "constantinopleBlock": 0,
    "petersburgBlock": 0,
    "istanbulBlock": 0,
    "ethash": {}
  },
  "nonce": "0x0",
  "timestamp": "0x5ddf8f3e",
  "extraData": "0x0000000000000000000000000000000000000000000000000000000000000000",
  "gasLimit": "0x47b760",
  "difficulty": "0x00002",
  "mixHash": "0x0000000000000000000000000000000000000000000000000000000000000000",
  "coinbase": "0x0000000000000000000000000000000000000000",
  "alloc": {
  },
  "number": "0x0",
  "gasUsed": "0x0",
  "parentHash": "0x0000000000000000000000000000000000000000000000000000000000000000"
}
```

```json
{
    "config": {
      "chainId": 123,
      "homesteadBlock": 0,
      "eip155Block": 0,
      "eip158Block": 0
  },
  "alloc": {
    "bc9a3ece02d7cb31cf63dfdfc48db0b82770d014": {
      "balance": "1000000000000000000000000000000"
    },
    "457e7d69fd3ac576aa744228e6b3319cde768473": {
      "balance": "2000000000000000000000000000000"
    },
    "926ef6011f7c852d30a01c7a4aaa5cbc460588fc": {
      "balance": "3000000000000000000000000000000"
    }
  },

  "nonce": "0x0000000000000056",
  "difficulty": "0x020000",
  "mixhash": "0x0000000000000000000000000000000000000000000000000000000000000000",
  "coinbase": "0x0000000000000000000000000000000000000000",
  "timestamp": "0x00",
  "parentHash": "0x0000000000000000000000000000000000000000000000000000000000000000",
  "extraData": "0x11bbe8db4e347b4e8c937c1c8370e4b5ed33adb3db69cbdb7a38e1e50b1b82fa",
  "gasLimit": "0x4c4b40"

}

```



chainId：链的唯一标识，不要跟主网1和测试网3、4、42一样

difficulty：挖矿难度设置

gasLimit：块的gas上线

alloc：键是地址，值是余额（可以有很多个键值对）

$ vi genesis.json 创建文件

文件按a开始编辑 按esc退出编辑 按:再加wq保存并退出

### 初始化私链

$ geth --datadir ~/project/myChain init ~/project/myChain/genesis.json 初始化一个私链

### 启动私链

$ geth --datadir ~/project/myChain --networkid 15

-  加上--nodiscover：禁止寻找节点，防止一直Looking for peers

- 加上2>output.log：2代表输出，2>s输出重定向，表示启动后的log输出到output.log文件中，用另一个终端cat该文件就可以查看日志，输出tail -f output.log可以实时查看日志



### 控制台

$ geth --datadir . --networkid 15 console 2>output.log启动的同时打开控制台

exit可以退出控制台

- web3 ：可以看到很多对象和方法

  - eth：和区块链交互，核心子对象

  - net ：p2p网络相关

  - miner：矿工挖矿

  - personal：和用户相关

  - providers：服务提供

  - txpool：交易池，发的交易会进来

  - admin：权限相关，和外部节点的连接和发现

- amdin：

  nodeInfo：我们启动的节点的信息

  peers：发现的周围节点

  network：连接的地址

### 日志重定向

$ geth --datadir . --networkid 15 --nodiscover console 2>output.log



$ geth --datadir . --networkid 123 console 2>output.log



cat output.log

tail -f output.log

### 后台启动和开启api

$ nohup geth --datadir . --networkid 123 2>output.log --rpc --rpcapi  "eth,personal,net,db,admin" $

可以用以下命令可以查看进程

$ ps -ef

重新进入控制台

$ geth attach http://loaclhost:8545

### 启动端口HTTP server started 

远程端口默认8545

$ geth --datadir . --networkid 123 --nodiscover --rpc console 2>output.log

(可以加--rpcprot来改变端口号)

$ geth --datadir . --networkid 123 --rpc --nodiscover --allow-insecure-unlock --syncmode fast  --rpcpi  "eth,personal,net,db,admin" console 2>output.log



$ geth --datadir . --networkid 123 --nodiscover --rpc --allow-insecure-unlock console 2>output.log

### 启动新链时创建开发者用户

$ geth --datadir . --dev --networkid 123 --rpc --allow-insecure-unlock console 2>output.log

### 常用命令

personal.newAccount()：创建账户；
personal.unlockAccount()：解锁账户；
eth.accounts：列出系统中的账户（keystore里的，初始化里面的账户并不存在这里）；
eth.getBalance()：查看账户余额，返回值的单位是 Wei；
eth.blockNumber：列出当前区块高度；
eth.getTransaction()：获取交易信息；
eth.getBlock()：获取区块信息；
miner.start()：开始挖矿；
miner.stop()：停止挖矿；
web3.fromWei()：Wei 换算成以太币；
web3.toWei()：以太币换算成 Wei；
txpool.status：交易池中的状态；

web3.fromWei( , "ether"):单位转换



```
eth.sendTransaction({from:eth.accounts[0],to:eth.accounts[1],value:1})

eth.getBalance(eth.accounts[0])

personal.unlockAccount(eth.accounts[0])

personal.unlockAccount(eth.accounts[0])

// 可以指定时间
personal.unlockAccount(eth.accounts[0],"xly1",3600)
```



### 一些问题

- 本身就在geth里面创建的用户就可以用accounts[0]来指定

- ```
  eth.sendTransaction({from:"0x717B24495437b9DEE698F14C643e318EA8d7Bd33",to:eth.accounts[0],value:1})
  ```

  会报错“Error: unknown account”，因为初始设置的节点不是geth管理的节点

- ```
  eth.sendTransaction({from:eth.accounts[0],to:"0x717B24495437b9DEE698F14C643e318EA8d7Bd33",value:1})
  ```

  上面两个用户反过来也不行，因为转账之前要解锁，personal.unlockAccount()

  但是里面没钱，会报错“insufficient funds for transfer”

- 有私钥可以直接导入用户

- ```
  eth.sendTransaction({from:eth.accounts[0],to:eth.accounts[1],value:100000000})
  ```

  并解锁accounts[0]是可以转账的，显示：

  ```
  INFO [09-21|14:38:26.889] Setting new local account             address=0x16A2a550449a2AD97A257b75Dcc31458929DE15a
  INFO [09-21|14:38:26.890] Submitted transaction                    hash=0x6222f7d5435c81f23509f06bf8cc78b2b187e20e54483fd2d756132311e69e28 from=0x16A2a550449a2AD97A257b75Dcc31458929DE15a nonce=0 recipient=0x952C8dC2d8fcba4A32b2f53E9F2EF7F08483840F value=100,000,000
  "0x6222f7d5435c81f23509f06bf8cc78b2b187e20e54483fd2d756132311e69e28"
  ```

  但是只有在启动挖矿后，交易才会进块

### 挖矿

setEtherbase：启动挖矿后前归谁

eth.blockNumber：查看块的数量

默认一个块5个ether

### 我的设置

密码xly1对应"0x3c28ba766598fcd11cf82921412d652fb33cac4c"

![alt](\3.png)

有这个文件和刚刚输入的密码就能解出私钥

## Coin.sol

```solidity
pragma solidity >0.4.22 <0.6.0;

contract Coin{
    address public minter;
    mapping(address=>uint) public balances;
    //发布这样一个事件
    event Sent(address from,address to,uint amount);
    //总量恒定 
    constructor() public{
        minter = msg.sender;
    }
    function send(address receiver,uint amount)public{
        require(balances[msg.sender] >= amount);
        //防止溢出 
        require(balances[receiver]+amount > balances[receiver]);
        balances[msg.sender] -= amount;
        balances[receiver] += amount;
        emit Sent(msg.sender,receiver,amount);
    }
}
```



# web3.js

## 下载web3模块

在工程目录下创建一个web3_test文件夹

然后

$ npm init

$ npm install web3@0.20.1 --save-dev

(--save-dev:加到本地package.json的开发环境依赖里)

### 错误示例

显示

```
npm ERR! Error while executing:
npm ERR! /usr/bin/git ls-remote -h -t https://github.com/frozeman/bignumber.js-nolookahead.git
npm ERR!
npm ERR! fatal: unable to access 'https://github.com/frozeman/bignumber.js-nolookahead.git/': GnuTLS recv error (-110): The TLS connection was non-properly terminated.
npm ERR!
npm ERR! exited with error code: 128
npm ERR! A complete log of this run can be found in:
npm ERR!     /home/xly/.npm/_logs/2021-09-26T12_17_49_713Z-debug.log
```

解决：

git config --global url.git://github.com/.insteadOf https://github.com/

## 编译

在web3_test文件夹下创建contract放合约

编译命令：

$ solcjs --abi Coin.sol

字节码文件：$ cat Coin_sol_Coin.bin

生成的接口文件：$ cat Coin_sol_Coin.abi

```
[
{
	"inputs":[
		{
			"internalType":"uint256",
			"name":"initalSupply",
			"type":"uint256"
		}
	],
	"stateMutability":"nonpayable",
	"type":"constructor"
},
{
	// 匿名
	"anonymous":false,
	"inputs":[
		{
			// 事件可以索引
			"indexed":false,
			"internalType":"address",
			"name":"from",
			"type":"address"
		},{
			"indexed":false,
			"internalType":"address",
			"name":"to",
			"type":"address"
		},{
			"indexed":false,
			"internalType":"uint256",
			"name":"amount",
			"type":"uint256"
		}
	],
	"name":"Sent",
	"type":"event"
},
{
	"inputs":[
		{
			"internalType":"address",
			"name":"",
			"type":"address"
		}
	],
	"name":"balances",
	"outputs":[
		{
			"internalType":"uint256",
			"name":"",
			"type":"uint256"
		}
	],
	"stateMutability":"view",
	"type":"function"
},
{
	"inputs":[
		{
			"internalType":"address",
			"name":"receiver",
			"type":"address"
		},
		{
			"internalType":"uint256",
			"name":"amount",
			"type":"uint256"
		}
	],
	"name":"send",
	"outputs":[
		{
			"internalType":"bool",
			"name":"success",
			"type":"bool"
		}
	],
	"stateMutability":"nonpayable",
	"type":"function"
}
]
```

## web3操作

先进入下载wbe3模块的文件夹，即web3_test

$ node

$ var Web3 = require('web3')

$ Web3

$ var web3 = new Web3(new Web3.providers.HttpProvider('http://localhost:8545'))

检测是否有连接：

$ web3.isConnected()

返回false说明要启动私链--rpc

$ rm -r web3_test可以删除一个文件夹



// 所有包都在node_modules中

$ var BigNumber = require('bignumber.js')

$ var balance = new BigNumber('31242344353464564564574574567456');

s是表示符号

e表示位数

c表示有效位数

## 常用API

### 基本信息查询

查看 web3 版本
• v0.2x.x：web3.version.api
• v1.0.0：web3.version

查看 web3 连接到的节点版本（ clientVersion ）
• 同步：web3.version.node
• 异步：web3.version.getNode((error,result)=>{console.log(result)})
• v1.0.0：web3.eth.getNodeInfo().then(console.log)也可以web3.eth.getNodeInfo().then(res=>console.log(res))

```js
// get方法是异步的
web3.version.getNode(function(err,res){console.log(res)})
```

获取 network id
• 同步：web3.version.network
• 异步：web3.version.getNetwork((err, res)=>{console.log(res)})
• v1.0.0：web3.eth.net.getId().then(console.log)

```js
web3.version.getNetwork(function(err,res){console.log(res)})
```

获取节点的以太坊协议版本
• 同步：web3.version.ethereum
• 异步：web3.version.getEthereum((err, res)=>{console.log(res)})
• v1.0.0：web3.eth.getProtocolVersion().then(console.log)

### 网络状态查询

是否有节点连接 / 监听，返回 true/false
• 同步：web3.isConnected() 或者 web3.net.listening
• 异步：web3.net.getListening((err,res)=>console.log(res))
• v1.0.0：web3.eth.net.isListening().then(console.log)

查看当前连接的 peer 节点
• 同步：web3.net.peerCount
• 异步：web3.net.getPeerCount((err,res)=>console.log(res))
• v1.0.0：web3.eth.net.getPeerCount().then(console.log)

### Provider

查看当前设置的 web3 provider
• web3.currentProvider

查看浏览器环境设置的 web3 provider （ v1.0.0 ）
• web3.givenProvider
（浏览器会自动给我们的页面注入web3，在F12下的console中输入web3可以查看）

设置 provider
连接之后也可以断开，没有连接也能获得web3，可以不用一定是本地的，也不用一定是http<不一定是--rpc,默认起来的是ipc，推进ws的方式，rpc也就是http不安全>
• web3.setProvider(provider)
• web3.setProvider(new web3.providers.HttpProvider('http://localhost:8545'))

### web3通用工具方法

（在1.0里面这些东西全部放到了web3.utils里面）

以太单位转换:
web3.fromWei 

web3.toWei

数据类型转换:
web3.toString 

web3.toDecimal 

web3.toBigNumber

字符编码转换:
web3.toHex 

web3.toAscii 

web3.toUtf8 

web3.fromUtf8

地址相关
web3.isAddress 

地址是20位，40个16进制字符

web3.toChecksumAddress

### web3.eth——账户相关

coinbase 查询
• 同步：web3.eth.coinbase
• 异步：web3.eth.getCoinbase( (err, res)=>console.log(res) )
• v1.0.0：web3.eth.getCoinbase().then(console.log)

账户查询
• 同步：web3.eth.accounts
• 异步：web3.eth.getAccounts( (err, res)=>console.log(res) )
• v1.0.0：web3.eth.getAccounts().then(console.log)

### 区块相关

区块高度查询
• 同步：web3.eth. blockNumber
• 异步：web3.eth.getBlockNumber( callback )



gasPrice 查询
• 同步：web3.eth.gasPrice

（返回是一个bigNumber，可以用web3.eth.gasPrice.toString()转换）

• 异步：web3.eth.getGasPrice( callback )



区块查询
• 同步：web3.eth.getBlock( hashStringOrBlockNumber[ ,returnTransactionObjects] )
• 异步：web3.eth.getBlock( hashStringOrBlockNumber, callback )



块中交易数量查询
• 同步：
web3.eth.getBlockTransactionCount( hashStringOrBlockNumber )
• 异步：
web3.eth.getBlockTransactionCount( hashStringOrBlockNumber, callback )

### 交易相关

余额查询
• 同步：web3.eth.getBalance(addressHexString [, defaultBlock])
• 异步：web3.eth.getBalance(addressHexString [, defaultBlock] [, callback])

交易查询
• 同步：web3.eth.getTransaction(transactionHash)
• 异步：web3.eth.getTransaction(transactionHash [, callback])

```js
web3.eth.getTransaction("0x0631b11fe0c0a99e07fc57cd27138cbc7d358bad26645b171f8925f0fa290c2c")
```



### 交易执行相关

• 交易收据查询（已进块）
• 同步：web3.eth.getTransactionReceipt(hashString)
• 异步：web3.eth.getTransactionReceipt(hashString [,
callback])

• 估计 gas 消耗量
• 同步：web3.eth.estimateGas(callObject)
• 异步：web3.eth.estimateGas(callObject [, callback])

 web3.eth.estimateGas({from:web3.eth.accounts[0],to:web3.eth.accounts[1],value:200000})

### 发送交易

• web3.eth.sendTransaction(transactionObject [, callback])

• 交易对象：
• from：发送地址
• to：接收地址，如果是创建合约交易，可不填
• value：交易金额，以wei为单位，可选
• gas：交易消耗 gas 上限，可选
• gasPrice：交易 gas 单价，可选
• data：交易携带的字串数据，可选
• nonce：整数 nonce 值，可选

（创建合约时没有to，消息调用时没有value）

### 消息调用

• web3.eth.call(callObject [, defaultBlock] [, callback])

一般用在不用发布交易的消息调用（不改变状态）

• 参数：
• 调用对象：与交易对象相同，只是from也是可选的
• 默认区块：默认“latest”，可以传入指定的区块高度
• 回调函数，如果没有则为同步调用

```js
var result = web3.eth.call({ to:
"0xc4abd0339eb8d57087278718986382264244252f",
data:
"0xc6888fa100000000000000000000000000000000000000000000000000
00000000000003" });
console.log(result);
```

（这里的data表示调用合约）

### 日志过滤（事件监听）

• web3.eth.filter( filterOptions [ , callback ] )

```js
// 分两步的方法：
// filterString 可以是 'latest' or 'pending'
// 'latest':总会监听最新进来的块
// 'pending':总会监听当前正在判定的交易
var filter = web3.eth.filter(filterString);
// 或者可以填入一个日志过滤 options
// options:fromBlock toBlock address topics
var filter = web3.eth.filter(options);
// 监听日志变化
filter.watch(function(error, result){ if (!error) console.log(result); });

// 直接启动的方法：
// 还可以用传入回调函数的方法，立刻开始监听日志
web3.eth.filter(options, function(error, result){
if (!error) console.log(result);
});
```

可以输入filter查看filter状态

### 合约相关——创建合约

 web3.eth.contract

```js
// 传入abi，创建一个js的合约（抽象）
var MyContract = web3.eth.contract(abiArray);

// 方法1
// 通过地址初始化合约实例（实例）
var contractInstance = MyContract.at(address);

// 方法2
// 或者部署一个新合约
var contractInstance = MyContract.new([constructorParam1]
[, constructorParam2], {data: '0x12345...', from:
myAccount, gas: 1000000});
// data是字节码
```

在contract目录下编译后的合约有两种文件，一种是abi，一种是bin。

abi文件存放的就是abiArray的内容

bin文件内容加上前缀0x，就是data的内容

```js
 var abi =[{"inputs":[{"internalType":"uint256","name":"initalSupply","type":"uint256"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"from","type":"address"},{"indexed":false,"internalType":"address","name":"to","type":"address"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"}],"name":"Sent","type":"event"},{"inputs":[{"internalType":"address","name":"","type":"address"}],"name":"balances","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"_addr","type":"address"}],"name":"getBalances","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"minter","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"receiver","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"send","outputs":[{"internalType":"bool","name":"success","type":"bool"}],"stateMutability":"nonpayable","type":"function"}]
 
 var CoinContract=web3.eth.contract(abi)
 var byteCode='0x'+'608060405234801561001057600080fd5b50604051610741380380610741833981810160405281019061003291906100d1565b336000806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555080600160003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000208190555050610124565b6000815190506100cb8161010d565b92915050565b6000602082840312156100e7576100e6610108565b5b60006100f5848285016100bc565b91505092915050565b6000819050919050565b600080fd5b610116816100fe565b811461012157600080fd5b50565b61060e806101336000396000f3fe608060405234801561001057600080fd5b506004361061004c5760003560e01c8063075461721461005157806327e235e31461006f578063c84aae171461009f578063d0679d34146100cf575b600080fd5b6100596100ff565b604051610066919061041c565b60405180910390f35b61008960048036038101906100849190610382565b610123565b6040516100969190610489565b60405180910390f35b6100b960048036038101906100b49190610382565b61013b565b6040516100c69190610489565b60405180910390f35b6100e960048036038101906100e491906103af565b610184565b6040516100f6919061046e565b60405180910390f35b60008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b60016020528060005260406000206000915090505481565b6000600160008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020549050919050565b600081600160003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205410156101d257600080fd5b600160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205482600160008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205461025d91906104a4565b1161026757600080fd5b81600160003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008282546102b691906104fa565b9250508190555081600160008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600082825461030c91906104a4565b925050819055507f3990db2d31862302a685e8086b5755072a6e2b5b780af1ee81ece35ee3cd334533848460405161034693929190610437565b60405180910390a16001905092915050565b600081359050610367816105aa565b92915050565b60008135905061037c816105c1565b92915050565b600060208284031215610398576103976105a5565b5b60006103a684828501610358565b91505092915050565b600080604083850312156103c6576103c56105a5565b5b60006103d485828601610358565b92505060206103e58582860161036d565b9150509250929050565b6103f88161052e565b82525050565b61040781610540565b82525050565b6104168161056c565b82525050565b600060208201905061043160008301846103ef565b92915050565b600060608201905061044c60008301866103ef565b61045960208301856103ef565b610466604083018461040d565b949350505050565b600060208201905061048360008301846103fe565b92915050565b600060208201905061049e600083018461040d565b92915050565b60006104af8261056c565b91506104ba8361056c565b9250827fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff038211156104ef576104ee610576565b5b828201905092915050565b60006105058261056c565b91506105108361056c565b92508282101561052357610522610576565b5b828203905092915050565b60006105398261054c565b9050919050565b60008115159050919050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b6000819050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b600080fd5b6105b38161052e565b81146105be57600080fd5b50565b6105ca8161056c565b81146105d557600080fd5b5056fea2646970667358221220246b5ad0be3cf18375ce6c93db965f922b3f9245edffcc84e164668663383ef464736f6c63430008070033'
 
var deployTxObject={from:web3.eth.accounts[0],data:byteCode,gas:1000000}

// 有参数的话一定要带上参数，不然合约一直会进不了块，没有adress
var coinContractInstance = CoinContract.new(50000000000000,deployTxObject)
```



### 调用合约函数

• 可以通过已创建的合约实例，直接调用合约函数

```js
// 直接调用，自动按函数类型决定用 sendTransaction 还是 call
myContractInstance.myMethod(param1 [, param2, ...] [,
transactionObject] [, defaultBlock] [, callback]);
// 显式以消息调用形式 call 该函数
myContractInstance.myMethod.call(param1 [, param2, ...] [,
transactionObject] [, defaultBlock] [, callback]);
// 显式以发送交易形式调用该函数
myContractInstance.myMethod.sendTransaction(param1 [,
param2, ...] [, transactionObject] [, callback]);
```

调用合约的函数时：Error: invalid address错误

```js
// 前面是两个函数的参数，最后一个是必须指出谁来调用这个合约，如果不加from则会报
coinContractInstance.send(web3.eth.accounts[1],1,{from:web3.eth.accounts[0]})
```



### 监听合约事件

• 合约的 event 类似于 filter，可以设置过滤选项来监听

```js
var event = myContractInstance.MyEvent({valueA: 23}
[, additionalFilterObject])
// 监听事件
event.watch(function(error, result){ if (!error) console.log(result); });

// 还可以用传入回调函数的方法，立刻开始监听事件
var event = myContractInstance.MyEvent([{valueA: 23}]
[, additionalFilterObject] , function(error, result){
if (!error) console.log(result);
}
);
```

# 用web3js写以太坊脚本

## 直接发币

```js
var Web3 = require('web3');
var web3 = new Web3(new Web3.providers.HttpProvider("http://localhost:8545"));

var _from = web3.eth.accounts[0];
var _to = "0xd4c7b8117d6f77c9466b38cbcbca074b5d63f1d3";

var _value = 5000000;

web3.eth.sendTransaction({from:_from,to:_to,value:_value},(err,res)=>{
    if(err)
        console.log("Error:",err);
    else
        console.log("Result(traHash)",res);
});
```

带输入版本：

```js
var Web3 = require('web3');
var web3 = new Web3(new Web3.providers.HttpProvider("http://localhost:8545"));

var arguments = process.argv.splice(2);
if(!arguments || arguments.length != 2){
    console.log("Parameter error!");
    return;
}
var _from = web3.eth.accounts[0];
var _to = arguments[0];
var _value = arguments[1];

web3.eth.sendTransaction({from:_from,to:_to,value:_value},(err,res)=>{
    if(err)
        console.log("Error:",err);
    else
        console.log("Result(traHash)",res);
});
```

## 转自己的币（而不是以太）

```js
var Web3 = require('web3');
var web3 = new Web3(new Web3.providers.HttpProvider("http://localhost:8545"));

var arguments = process.argv.splice(2);
if(!arguments || arguments.length != 2){
    console.log("Parameter error!");
    return;
}

var _from = web3.eth.accounts[0];
var _to = arguments[0];
var amount = arguments[1];

var abi = [{"inputs":[{"internalType":"uint256","name":"initalSupply","type":"uint256"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"from","type":"address"},{"indexed":false,"internalType":"address","name":"to","type":"address"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"}],"name":"Sent","type":"event"},{"inputs":[{"internalType":"address","name":"","type":"address"}],"name":"balances","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"_addr","type":"address"}],"name":"getBalances","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"minter","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"receiver","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"send","outputs":[{"internalType":"bool","name":"success","type":"bool"}],"stateMutability":"nonpayable","type":"function"}];

var CoinContract = web3.eth.contract(abi);
var contractAddress = '0xa2715b10453bae8cd569da78c507bf7fa34900fe';
var contractInstance = CoinContract.at(contractAddress);

web3.personal.unlockAccount(_from,'xly1',(err,res)=>{
    if(err)
        console.log("unlockAccountError:",err);
    else{
        console.log("unlockAccountResult:",res);
        contractInstance.send(_to,amount,{from:_from},(err,res)=>{
    		if(err)
        		console.log("Error:",err);
    		else
        		console.log("Result:",res);
		});
    }
        
});


```

后面的{}中如果要写to，是写的合约的地址，如果加了value表示要给合约发的币，前面的amount是发的我们自己的代币（和以太无关）

personal想用的话要开启api

$ geth --datadir . --networkid 123 --rpc --nodiscover --allow-insecure-unlock --syncmode fast  --rpcapi "eth,personal,net,db,admin" console 2>output.log

回调是异步操作的，所以用回调验证正确时，注意执行顺序，或者可以用.then

调用js：

```
node sendCoin.js 0x44eba9c4e64c3e5b44cc387274d8b29995566eea 11
```

## 查询

```js
var Web3 = require('web3');
var web3 = new Web3(new Web3.providers.HttpProvider("http://localhost:8545"));

var arguments = process.argv.splice(2);
if(!arguments || arguments.length != 1){
    console.log("Parameter error!");
    return;
}

var _addr = arguments[0];

var abi = [{"inputs":[{"internalType":"uint256","name":"initalSupply","type":"uint256"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"from","type":"address"},{"indexed":false,"internalType":"address","name":"to","type":"address"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"}],"name":"Sent","type":"event"},{"inputs":[{"internalType":"address","name":"","type":"address"}],"name":"balances","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"_addr","type":"address"}],"name":"getBalances","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"minter","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"receiver","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"send","outputs":[{"internalType":"bool","name":"success","type":"bool"}],"stateMutability":"nonpayable","type":"function"}];

var CoinContract = web3.eth.contract(abi);
var contractAddress = '0xa2715b10453bae8cd569da78c507bf7fa34900fe';
var contractInstance = CoinContract.at(contractAddress);

contractInstance.getBalances.call(_addr,(err,res)=>{
    if(err)
        console.log("Error:",err);
    else
        console.log("Result:",res.toString());
});
```

## 监听

```js
var Web3 = require('web3');
var web3 = new Web3(new Web3.providers.HttpProvider("http://localhost:8545"));

var abi = [{"inputs":[{"internalType":"uint256","name":"initalSupply","type":"uint256"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"from","type":"address"},{"indexed":false,"internalType":"address","name":"to","type":"address"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"}],"name":"Sent","type":"event"},{"inputs":[{"internalType":"address","name":"","type":"address"}],"name":"balances","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"_addr","type":"address"}],"name":"getBalances","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"minter","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"receiver","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"send","outputs":[{"internalType":"bool","name":"success","type":"bool"}],"stateMutability":"nonpayable","type":"function"}];

var CoinContract = web3.eth.contract(abi);
var contractAddress = '0xa2715b10453bae8cd569da78c507bf7fa34900fe';
var contractInstance = CoinContract.at(contractAddress);

contractInstance.Sent("latest",(err,res)=>{
    if(err)
        console.log("Error:",err);
    else
        console.log("Sent Event occurs:",res);
});

```

后台启动

$ node sentEvent_listener.js &

## 问题

balances和getBalances调用后都返回的是一个交易哈希，如果想获得返回值，就要使用call方法

```js
// 错误
contractInstance.balances(web3.eth.accounts[1],{from:web3.eth.accounts[0]})
// 正确
contractInstance.balances.call(web3.eth.accounts[1],{from:web3.eth.accounts[0]})
```

# 简单投票DApp

## ganache 

模拟区块链，能够让我们的程序在开发环境中
运行

合约并部署到 ganache 上

通过命令行和网页与 ganache 进行交互

就是默认了一个--dev

为了便于测试，ganache 默认会创建 10 个账户，每个账户有 100 个以太。你需要用其中一个账户创建交易，发送、接收以太。
当然，你也可以安装 GUI 版本的 ganache 而不是命令行版本，在这里下载 GUI 版本：http://truffleframework.com/ganache/

## 安装环境

### 安装

```
$ mkdir simple_voting_dapp
$ cd simple_voting_dapp
$ npm init
$ npm install ganache-cli web3@0.20.1 solc@0.4.22
```

### 启动

$ node_modules/.bin/ganache-cli

```
Available Accounts
==================
(0) 0x5eC03d8c557709C59B3d14Cd7027c10440aF0aB7 (100 ETH)
(1) 0x1aC79037bf58ac3Ae0074D1e84400e764f1E1247 (100 ETH)
(2) 0xBB0Ff8dA1A89c98DBac36AE9806bf461d22bA5bE (100 ETH)
(3) 0x042Db0efdEE0932d7CAdba70fD416889593Fc3F4 (100 ETH)
(4) 0xF71a111aa37Fc23BC03F4d7df7ADCBEAa1F2E1cb (100 ETH)
(5) 0xd62129bf613357883Ab9cC35502E5e5d3E9ac75a (100 ETH)
(6) 0x59671D402D0C4488d47D33337B28957a1551E073 (100 ETH)
(7) 0x7D643111E894e73278105A5eeC6C03ff7B76D22a (100 ETH)
(8) 0xd25A598a2Ec0fB24564F971AEe9b035E69C967d7 (100 ETH)
(9) 0x371Cd4680550754eEEF656043D578cE7f93FC9be (100 ETH)

Private Keys
==================
(0) 0x318ef0b78fcbbcd7f8a79550e5396236536a112efee77b94d62db3819eb4a601
(1) 0x46f2601819c35f9ff3181b137563c0b20ef3f07e166363044f4bcb4797a53581
(2) 0x9b4fc1067ebc902615e623831e06bb22a86ebac65511d646976c16d9211af5ab
(3) 0xf78cb1d9ed661c192eb7fda8a98a8f9c39bc898493ebb3ad47e51930887f3d03
(4) 0x2e5d52a380bfa30bc8d8bc3c0f48957e81a142236035bc4776c3ce5c7a7368cc
(5) 0xca597c2f859c73af7f0cdd7eb2d66024db618f0fc01882de0460f9b969423746
(6) 0xb207bc3c7c54d949d68e77d30fef3831f018c4fc98b7160126f7b5e8c42f5811
(7) 0x40aa7dc776ba755529da97dccf34bd1f57b60c12404a7fd3f7fc402433c56616
(8) 0x99e92d23394455ee9c8c1653107409657dbcd17491de2c970676d240d9a1e6df
(9) 0x4034a185d959500d391c685e458ab4d12fd5e88aef90f803815a5b580688008c
```

### 帮助

$ ./node_modules/.bin/ganache-cli --help可以查看帮助

$ npm list web3可以查看安装的版本

$ npm list solc可以查看安装的版本

## solidity代码

```
// SPDX-License-Identifier: MIT
pragma solidity >0.4.22;

contract Voting {
    mapping (bytes32 => uint8) public votesReceived;
    bytes32[] public candidateList;
    constructor(bytes32[] memory candidateNames){
        candidateList = candidateNames;
    }
    
    function totalVotesFor(bytes32 candidate) view public returns (uint8) {
        require(validCandidate(candidate));
        return votesReceived[candidate];
    }
    
    function voteForCandidate(bytes32 candidate) public {
        require(validCandidate(candidate));
        votesReceived[candidate] += 1;
    }
    
    function validCandidate(bytes32 candidate) view public returns (bool) {
        for(uint i = 0; i < candidateList.length; i++) {
            if (candidateList[i] == candidate) {
                return true;
            }
        }
        return false;
    }
}
```

## 编译

在simple_voting_dapp文件中

```js
$ node
var Web3 = require('web3')
var web3 = new Web3(new Web3.providers.HttpProvider('http://localhost:8545'))
web3.isConnected()
web3.eth.accounts
var solc = require("solc")

var sourceCode = fs.readFileSync('contract/Voting.sol').toString()
var compiledCode = solc.compile(sourceCode)
```

fs.readFileSync可能会有权限问题permission denied, open 'contract/Voting.sol'

```
sudo chmod 777 contract
sudo chmod 666 Voting.sol
```

版本错误：

```
下载的时候指定solc@0.4.22
```

## 部署

```js
var abi = JSON.parse(compiledCode.contracts[':Voting'].interface);

var byteCode = compiledCode.contracts[':Voting'].bytecode;

var VotingContract = web3.eth.contract(abi);

var deployTxObj = {data: byteCode,from:web3.eth.accounts[0],gas:3000000};

var contractInstance =  VotingContract.new(['Alice','Bob','Cary'],deployTxObj);

contractInstance.address
// 返回：
'0x08971ae33078b7e34e53ec995c3e0a00d9fba722'

contractInstance.voteForCandidate("Alice",{from:web3.eth.accounts[0]})

// call
contractInstance.totalVotesFor.call("Bob",{from:web3.eth.accounts[0]}).toString()
// sendTransaction
contractInstance.totalVotesFor.sendTransaction("Cary",{from:web3.eth.accounts[0]}).toString()


```

## 部署html，js

```

```

## 部署服务器

```js
var http=requrie('http');
var fs = requrie('fs');
var url = requrie('url');

http.createServer(function(req,res{
	var pathName = url.parse(req.url).pathName;
    console.log("Request for:" + pathName +"received.");
	
	fs.readFileSync(pathName, function(err,data){
        if(err)
            console.log(err);
        else{
            res.writeHead(200,{});
            res.write(data.toString());
        }
    })
});
```